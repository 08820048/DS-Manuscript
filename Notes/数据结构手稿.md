# 数据结构手稿

## 前言？

喜欢`NiklausWirth`的一句话:**程序=数据结构+算法**。

但这篇文章的目的不在于去抠很多的理论内容，而是直截了当的通过画图结合的方式展现数据结构的基础操作以及代码演示，所以，这篇文章并**不适合用来作为应考**的小册子，更多的是学习数据结构的**实战与基本原理**。

~~个人也是学习者，能力有限，其中不乏有错误遗漏之处，欢迎指正！~~

**代码使用C++语言。**

****

## 图解？

这个是我自己的定义，就是通过纸张手稿画图的形式展现数据结构，本来想通过`iPad`手绘的形式展现的，无奈贫穷封印了我的`iPad`，所以就只能通过草稿纸草图了，图纸中涉及到的图与字可能比较抽象，凑合看看。

****

## 1、顺序表

### 1.1 顺序表的基本操作

结构体定义:

```cpp
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;
```

> - 初始化
> - 创建
> - 取值
> - 查找
> - 插入
> - 删除

#### 1.1.1初始化(InitList)

初始化就是为顺序表分配一个预定的表长(假设为`MaxSize`)。那么就用`new`关键字给表分配一个预定大小的空间，若分配成功返回空间的首地址，否则返回空指针(`nullptr`)用val记录这段空间的基地址，由于初始化时表中没有元素，所以元素的实际长度`length`为`0`。

**图解:**

![a1fc4acab7d3485a3d62068de427703](https://images.waer.ltd/notes/202305031819552.jpg)

**代码实现:**

```cpp
/**
 * 初始化顺序表
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}
```

**含测试:**

```cpp
/**
* Author: 八尺妖剑
* Date: 2023/5/3
* Email: ilikexff@gmail.com
* Blog: https://waer.ltd
* Desc: 顺序表的基本操作
**/

#include <iostream>
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;

bool InitList(SqlList &L);

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    for(int i=0;i<10;i++)
    {
        L.val[i] = i+1;
        L.length++;
    }

    cout << "插入10个元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    delete[] L.val;

    return 0;
}

/**
 * 初始化顺序表
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}
```

> 初始化成功!
> 插入10个元素之后，顺序表的长度:10
> 顺序表的元素为:
> 1 2 3 4 5 6 7 8 9 10

****

#### 1.1.2创建(CreateList)

即向初始化好的顺序表中依次添加数据元素。

**算法步骤:**

- 初始化索引变量`i=0`，判断顺序表是否表满，是则结束，否则继续;
- 输入数据元素`x`;
- 将数据存入顺序表的第`i`个位置，即`L.val[i] = x`,然后递增索引`i`。
- 顺序表长度递增。
- 完成创建。

下面的图解步骤以向顺序表中添加`5,3,6`为例：
![a816fd51d71eaedb8eafc3d5aa87873](https://images.waer.ltd/notes/202305031826109.jpg)

![59dcbede862a24bdb13c9e8106865e1](https://images.waer.ltd/notes/202305031827712.jpg)

![77069055d9c8a363fcaa792c5bcddd7](https://images.waer.ltd/notes/202305031827326.jpg)

**代码实现:**

```cpp
/**
 * 顺序表的创建
 * @param L 顺序表的引用
 * @return bool
 */
bool CreateList(SqlList &L)
{
    int i = 0,x=0;
    std::cin >> x;
    while(x!=-1) //代表输入-1时结束输入
    {
        if(L.length == MaxSize)
        {
            std::cout <<"哦吼！表满了。";
            return false;
        }
        L.val[i++] = x; // #3 向顺序表添加元素并递增索引
        L.length++; //#4 长度递增
        std::cin >> x;
    }
    return true;
}
```

**含测试:**

```cpp
/**
* Author: 八尺妖剑
* Date: 2023/5/3
* Email: ilikexff@gmail.com
* Blog: https://waer.ltd
* Desc: 顺序表的基本操作
**/

#include <iostream>
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;

bool InitList(SqlList &L);
bool CreateList(SqlList &L);
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    // 测试创建函数
    if (!CreateList(L))
    {
        cout <<"创建失败!" << endl;
    }
    cout <<"创建成功!" << endl;
    cout << "插入3个元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    delete[] L.val;

    return 0;
}

/**
 * 顺序表的初始化
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}


/**
 * 顺序表的创建
 * @param L 顺序表的引用
 * @return bool
 */
bool CreateList(SqlList &L)
{
    int i = 0,x=0;
    std::cin >> x;
    while(x!=-1) //输入-1时结束输入
    {
        if(L.length == MaxSize)
        {
            std::cout <<"哦吼！表满了。";
            return false;
        }
        L.val[i++] = x; // #3 向顺序表添加元素并递增索引
        L.length++; //#4 长度递增
        std::cin >> x;
    }
    return true;
}
```

> [------------------初始化函数测试---------------]
> 初始化成功!
> [------------------创建函数测试---------------]
> 5
> 3
> 9
> -1
> 创建成功!
> 插入3个元素之后，顺序表的长度:3
> 顺序表的元素为:
> 5 3 9 

****

#### 1.1.3取值(GetVal)

根据指定的索引`i`返回对应得到元素值`v`。

**算法步骤:**

- 索引合法性判断(是否超出上下界)；
- 将第`i`处位置对应的元素值`val[i-1]`赋给`v`;
- 返回`true`，方法结束。

> 注意索引和位置的关系，这里所说的位置是指在顺序表中的第几个元素，而索引是顺序表的下标序号，位置和索引差1(即索引+1=位置)，因此，我们要获取第i个位置的元素，其实就是val[i-1]处的元素。

**图解:**

![25f987744047a1a439dc67576185dfc](https://images.waer.ltd/notes/202305031855859.jpg)

**代码实现:**

```cpp
/**
 * 获取第n个元素
 * @param L 表引用
 * @param i 位置
 * @param v 存储获取到的元素值的引用
 * @return bool
 */
bool GetVal(SqlList &L,int i,int &v)
{
    for (i <1 || i > L.length)
    {
        std::cout <<"非法位置";
        return false;
    }
    v = L.val[i-1]；
    return true;    
}
```

**含测试:**

```cpp
/**
* Author: 八尺妖剑
* Date: 2023/5/3
* Email: ilikexff@gmail.com
* Blog: https://waer.ltd
* Desc: 顺序表的基本操作
**/

#include <iostream>
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;

void TestPrint(const std::string &str);
bool InitList(SqlList &L);
bool CreateList(SqlList &L);
bool GetVal(SqlList &L,int i,int &v);
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    TestPrint("------------------初始化函数测试---------------");
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    // 测试创建函数
    TestPrint("------------------创建函数测试---------------");
    if (!CreateList(L))
    {
        cout <<"创建失败!" << endl;
    }
    cout <<"创建成功!" << endl;

    cout << "插入3个元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    // 测试获取元素函数
    TestPrint("------------------获取函数测试---------------");
    int v;
    if (!GetVal(L,3,v))
    {
        cout <<"获取失败!";
    }
    cout <<"第" << 3 << "个位置的元素为:" << v <<endl;
    delete[] L.val;

    return 0;
}

void TestPrint(const std::string &str)
{
    std::cout << "[" <<str <<"]" << std::endl;
}



/**
 * 顺序表的初始化
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}


/**
 * 顺序表的创建
 * @param L 顺序表的引用
 * @return bool
 */
bool CreateList(SqlList &L)
{
    int i = 0,x=0;
    std::cin >> x;
    while(x!=-1) //代表输入-1时结束输入
    {
        if(L.length == MaxSize)
        {
            std::cout <<"哦吼！表满了。";
            return false;
        }
        L.val[i++] = x; // #3 向顺序表添加元素并递增索引
        L.length++; //#4 长度递增
        std::cin >> x;
    }
    return true;
}


/**
 * 获取第n个元素
 * @param L 表引用
 * @param i 位置
 * @param v 存储获取到的元素值的引用
 * @return bool
 */
bool GetVal(SqlList &L,int i,int &v)
{
    if (i < 1 || i > L.length)
    {
        std::cout <<"非法位置";
        return false;
    }
    v = L.val[i-1];
    return true;
}
```

> [------------------初始化函数测试---------------]
> 初始化成功!
> [------------------创建函数测试---------------]
> 5
> 3
> 9
> -1
> 创建成功!
> 插入3个元素之后，顺序表的长度:3
> 顺序表的元素为:
> 5 3 9 
> [------------------取值函数测试---------------]
> 第3个位置的元素为:9

****

#### 1.1.4查找(LocateVal)

在顺序表中查找指定元素v。

从头遍历顺序表，依次比较元素是否等于指定值，是则返回其索引，否则返回-1.

**代码实现:**

```cpp
/**
 * 查找指定元素
 * @param L  顺序表
 * @param v 指定元素
 * @return 成功返回元素索引，失败返回-1
 */
int  LocateVal(SqlList L,int v)
{
    int i;
    for(i=0;i<L.length;i++)
    {
        if (L.val[i] == v) return i;
    }
    return -1;
}
```

**含测试:**

```cpp
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    TestPrint("------------------初始化函数测试---------------");
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    // 测试创建函数
    TestPrint("------------------创建函数测试---------------");
    if (!CreateList(L))
    {
        cout <<"创建失败!" << endl;
    }
    cout <<"创建成功!" << endl;

    cout << "插入元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    // 测试获取元素函数
    TestPrint("------------------取值函数测试---------------");
    int v;
    if (!GetVal(L,3,v))
    {
        cout <<"获取失败!";
    }
    cout <<"第" << 3 << "个位置的元素为:" << v <<endl;
    // 测试查找函数
    TestPrint("------------------查找函数测试---------------");
    v = -2;
    int index = LocateVal(L,v);
    if (index != -1)
        cout <<"元素" << v <<"的索引为:" << index <<endl;
    else
        cout <<"查找失败!";

    delete[] L.val;

    return 0;
}

/**
 * 查找指定元素
 * @param L  顺序表
 * @param v 指定元素
 * @return 成功返回元素索引，失败返回-1
 */
int  LocateVal(SqlList L,int v)
{
    int i;
    for(i=0;i<L.length;i++)
    {
        if (L.val[i] == v) return i;
    }
    return -1;
}
```

> 顺序表的元素为:
> 0 3 45 6 -23 8 -2 10 
> [------------------取值函数测试---------------]
> 第3个位置的元素为:45
> [------------------查找函数测试---------------]
> 元素-2的索引为:6

**算法复杂度:**

- 最好情况:

  如果需要查找的目标元素刚好在顺序表第一个位置，那么只需要比较一次即可查找成功，此时时间复杂度:
  $$
  O(1)
  $$

- 平均情况:

  由上，假设目标元素在第一个位置需要比较`1`次，第二个位置需要比比较`2`次...则最后一个位置处需要比较 `n`次。 

  得出:元素在第`i`个位置则需要比较`i`次，那么把所有情况下的比较次数乘以每次的查找概率`pi`并求和的结果即为平均时间复杂度。

  假设查找概率均等且均为`1/n`，则有：
  $$
  \sum_{n}^{i=1}p_{i}\times i = \frac{1}{n}\sum_{n}^{i=1}=\frac{1}{n}(1+2+3+...+n)=\frac{n+1}{2}
  $$
  所以，若假设**每个元素的查找概率相等**成立，则顺序表的平均时间复杂度:
  $$
  O(n)
  $$

- 最坏情况:

  如果目标元素刚好在顺序表最后一个位置，则需要比较`n`次查找成功，则其时间复杂度:
  $$
  O(n)
  $$

****

#### 1.1.5插入(ListInsert)

在顺序表中第`i`个位置之前插入一个元素`v`。

在插入元素之前，我们需要顺序表从最后一个元素开始后移一位，直到将第`i`个元素也后移一位。

这样做的目的是给待插入元素留出一个空位。

**算法步骤:**

- 判断所给目标插入位置`i`的合法性，(在第一个元素之前或者最后一个元素之后插入)。
- 判断是否表满。
- 依次后移，给目标元素流出插入的空位(空出第`i`个位置)。
- 将目标元素插入到第`i`个位置。
- 表长递增，完成插入。

**图解：**

> 下图以在顺序表:`[8,7,-1,2,0,11,1]`中的第5个位置之前插入元素`5`的步骤为例。

1. 从最后一个元素开始，将元素`1`后移一位。

![c54a72753a1b57102b70c71d7f96784](https://images.waer.ltd/notes/202305042142229.jpg)

2. 继续，将元素`11`后移一位。

![665d00d02a389d933bb9da9aff7dd4a](https://images.waer.ltd/notes/202305042143051.jpg)

3. 继续，将元素`0`后移一位。

![bfbd0d0505c445a483e5ac440848fba](https://images.waer.ltd/notes/202305042144584.jpg)

4. 此时空出了第`5`个位置。

![bfbd0d0505c445a483e5ac440848fba](https://images.waer.ltd/notes/202305042147644.jpg)

5. 将目标元素`5`插入到该空位，完成插入。

![91adffca0a998b4a55bb2f78b8d29f4](https://images.waer.ltd/notes/202305042148704.jpg)

**代码实现:**

```cpp
bool ListInsert(SqlList &L,int i,int v)
{
    if (i<1 || i > L.length + 1) return false; //插入位置合法性判断
    if (L.length == MaxSize) return false; //表满，无法插入
    for (int j = L.length-1;j >=i-1;j--) // 移位
        L.val[j+1] = L.val[j];
    L.val[i-1] = v; // 插入
    L.length++;
    return true; //完成插入
}
```

> [------------------插入函数测试---------------]
> 成功向第5个位置插入了元素:5
> 插入元素之后，顺序表的长度:8
> 顺序表的元素为:
> 8 7 -1 2 5 0 11 1

**算法复杂度:**

- 最好情况:

  当在顺序表表尾插入一个元素时，复杂度为常数级别:
  $$
  O(1)
  $$

- 平均情况:

  元素可以在第1个位置之前，第2个位置之前...第n个位置之前，第n+1个位置之前插入，共`n+1`种情况，每种情况的移动次数`n-i+1`。同理，将每种情况的移动次数乘以插入概率(假设为pi)并求和即为平均时间复杂度。因此，若每个位置的插入概率均为`1/(n+1)`,则:
  $$
  \sum_{i=1}^{n+1}p_{i}\times (n-i+1) = \frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{1}{n+1}(n+(n-1)+...+1+0)=\frac{n}{2}
  $$
  所以，平均时间复杂度为:
  $$
  O(n)
  $$

- 最坏情况:
  $$
  O(n)
  $$



****

#### 1.1.6删除(ListDelete)

与插入类似，这里所说的删除也是删除第`i`个元素，顺序表的删除操作，本质上就是将待删除的元素后面的元素依次往前移动，直到覆盖掉删除元素所留出的空位，完成删除。

**算法步骤:**

- 删除位置的合法性判断；
- 暂存待删除元素`v`;
- 将第`i+1`到第`n`个元素依次前移一个位置；
- 表长减1，完成删除；

**图解**

> 手稿以删除顺序表:`[8,7,-1,2,0,11,12,9]`中的第5个元素的步骤为例。

1. 确定待删除的目标元素`0`，将其后一个元素`11`前移一位，此时空出原`11`所在的位置；

![img_v2_39eb32ca-d625-40c1-af52-90cae0db8d4g](https://images.waer.ltd/notes/202305052109684.jpg)

2. 将空位之后的下一个元素`12`前移一位，空出自身的位置；

![img_v2_7c5260a6-eb88-497b-838f-328110ae1aag](https://images.waer.ltd/notes/202305052111598.jpg)

3. 同理，将元素`9`继续前移，此时整个顺序表长度减`1`,完成删除；

![img_v2_76bdd789-c44f-4c16-9913-56a32f7ee02g](https://images.waer.ltd/notes/202305052112157.jpg)

**代码实现:**

```cpp
/**
 * 删除第i个元素
 * @param L 顺序表
 * @param i 第i个元素
 * @param v 暂存待删除的元素
 * @return bool
 */
bool ListDelete(SqlList &L,int i,int &v)
{
    if (i < 1 || i >L.length) return false; //合法性判断
    v = L.val[i-1]; // 暂存待删除的元素，如果确定不需要返回删除元素的情况下，可以省略这一步
    for (int j = i;j <= L.length-1;j++)
        L.val[j-1] = L.val[j]; //第i个后面的元素依次向前移动
    L.length--;
    return true;
}
```

**算法复杂度:**

​	顺序表元素的删除一共有`n`种情况，每种情况移动的次数为`n-i`。将移动次数乘以删除概率`pi`,即为平均时间复杂度，假设删除每个元素的概率相等且为`1/n`，则平均时间复杂度:
$$
\sum_{i=1}^{n}p_{i}\times (n-i) = \frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{1}{n}((n-1)+...+1+0)=\frac{n-1}{2}
$$
即:
$$
O(n)
$$

****

#### 1.1.7完整的测试代码

```cpp
// 测试初始化函数
void test_InitList() {
    SqlList L;
    bool res = InitList(L);
    if (res) {
        cout << "InitList测试通过" << endl;
    } else {
        cout << "InitList测试不通过" << endl;
    }
}
// 测试创建函数
void test_CreateList() {
    SqlList L;
    bool res = CreateList(L);
    if (res) {
        cout << "CreateList测试通过" << endl;
    } else {
        cout << "CreateList测试不通过" << endl;
    }
}
// 测试获取元素函数
void test_GetVal() {
    SqlList L;
    bool res = InitList(L);
    if (!res) {
        cout << "GetVal测试不通过，顺序表初始化失败" << endl;
        return;
    }
    res = CreateList(L);
    if (!res) {
        cout << "GetVal测试不通过，顺序表创建失败" << endl;
        return;
    }
    int i = 0;
    cout << "请输入要获取的第几个元素的位置（1-" << L.length << "）：";
    cin >> i;
    int v;
    res = GetVal(L, i, v);
    if (res) {
        cout << "GetVal测试通过，获取到第" << i << "个元素是" << v << endl;
    } else {
        cout << "GetVal测试不通过" << endl;
    }
}
// 测试查找元素函数
void test_LocateVal() {
    SqlList L;
    bool res = InitList(L);
    if (!res) {
        cout << "LocateVal测试不通过，顺序表初始化失败" << endl;
        return;
    }
    res = CreateList(L);
    if (!res) {
        cout << "LocateVal测试不通过，顺序表创建失败" << endl;
        return;
    }
    int v = 0;
    cout << "请输入要查找的元素值：";
    cin >> v;
    int index = LocateVal(L, v);
    if (index != -1) {
        cout << "LocateVal测试通过，元素" << v << "的位置是" << index + 1 << endl;
    } else {
        cout << "LocateVal测试不通过" << endl;
    }
}
// 测试插入元素函数
void test_ListInsert() {
    SqlList L;
    bool res = InitList(L);
    if (!res) {
        cout << "ListInsert测试不通过，顺序表初始化失败" << endl;
        return;
    }
    res = CreateList(L);
    if (!res) {
        cout << "ListInsert测试不通过，顺序表创建失败" << endl;
        return;
    }
    cout << "请输入要插入的位置和值（位置从1开始）：";
    int i, v;
    cin >> i >> v;
    res = ListInsert(L, i, v);
    if (res) {
        cout << "ListInsert测试通过，插入成功，插入后的列表为：";
        for (int j = 0; j < L.length; j++) {
            cout << L.val[j] << " ";
        }
        cout << endl;
    } else {
        cout << "ListInsert测试不通过" << endl;
    }
}
// 测试删除元素函数
void test_ListDelete() {
    SqlList L;
    bool res = InitList(L);
    if (!res) {
        cout << "ListDelete测试不通过，顺序表初始化失败" << endl;
        return;
    }
    res = CreateList(L);
    if (!res) {
        cout << "ListDelete测试不通过，顺序表创建失败" << endl;
        return;
    }
    cout << "请输入要删除的位置（位置从1开始）：";
    int i;
    cin >> i;
    int v;
    res = ListDelete(L, i, v);
    if (res) {
        cout << "ListDelete测试通过，删除成功，删除的元素值为" << v << "，删除后的列表为：";
        for (int j = 0; j < L.length; j++) {
            cout << L.val[j] << " ";
        }
        cout << endl;
    } else {
        cout << "ListDelete测试不通过" << endl;
    }
}
// 测试入口函数
int main() {
    test_InitList();
    test_CreateList();
    test_GetVal();
    test_LocateVal();
    test_ListInsert();
    test_ListDelete();
    return 0;
}
```

****

#### 1.1.8小结

**顺序表优点:**

- 操作简单，存储密度高，可以随机存取，其中取出元素只需要`O(1)`的时间；

**顺序表缺点:**

- 需要预先计算好并分配所需空间，否则可能会造成空间浪费。

- 插入和删除操作需要移动其他元素，牵一发而动全身，效率不高。

****



## 2、单链表

**基本概念:**

在顺序表中，元素可以通过索引的方式随机存取。但单链表中，要查找某一个元素则必须通过从头开始遍历的方式逐一查找，单链表中并没有索引或者下标一说。

****

### 2.1单链表的基本操作

一般我们可以使用 元素+指针的结构定义一个单链表，元素指的是专门用来存储数据的空间，而指针则是用于指向下一个同类型(元素+指针)的结构，由此便可以将数据构造成一条链状的结构，即单链表的存储结构。

![img_v2_583e568c-72a6-431c-bc14-7d8d89ced68g](https://images.waer.ltd/notes/202305071411001.jpg)

但一般为了方便操作，可以给链表添加一个虚拟头节点(`dummy`节点)。`dummy`节点不存储与链表相关的数据元素以及指向指针，仅仅作为辅助节点使用。比如下图中的`head`即为`dummy`节点。

![img_v2_4ecc5b56-45e3-494c-8e8d-004d1b1f1f2g](https://images.waer.ltd/notes/202305071415543.jpg)

**结构定义:**

```cpp
typedef int ElemType;
typedef struct Node
{
    ElemType data;
    struct Node *next;
} Node,*LinkList;
```

****

#### 2.1.2初始化(InitLinkList)

即构建一个不存储任何数据且`next`指针指向`nullptr`的空链表。

![img_v2_252e6be2-31bb-4b2a-aa41-8cb7b2d6fd6g](https://images.waer.ltd/notes/202305071529346.jpg)

**代码实现:**

```cpp
/**
 * 初始化单链表
 * @param L 单链表
 * @return bool
 */
bool InitLinkList(LinkList &L)
{
    L = new Node; // 创建链表L
    if(!L)
        return false;
    L->next = nullptr; // 指针指向nullptr
    return true;
}
```

****

#### 2.1.3创建(CreateLinkList)

##### 2.1.3.1**头插法**：

所谓的头插法，就是将待插入的节点插入到头节点的前面(**左边**)。所以用这种方式创建的单链表中与数据输入顺序刚好是相反的，即**先插入(先输入)的数据会逐步往链表的右边靠拢**，当全部数据插入结束之后，整条链表从左(**头节点)**到右(**尾节点**)看起来的输入顺序就是反向排列的：

![img_v2_51526185-298f-4607-abec-16138ed9e86g](https://images.waer.ltd/notes/202305071840656.jpg)

**图解：**

1. 创建一个新节点`L`(即`dummy`节点)以及待插入的新节点`s`,将`s`插入到`L`之后，作为链表的第一个头节点；

![img_v2_91f2d775-d2d8-4a57-ad9d-35bb2f3e904g](https://images.waer.ltd/notes/202305071847491.jpg)

> 插入顺序:

```cpp
s->next = L->next;
L->next = s;
```

注意，由于`L->next`原来就是指向`nullptr`的，所以经过`s->next = L->next`之后，`s`就自然指向了一个`nullptr`节点，称为新的(无后继)的头节点。

之后每插入一个新的节点都将插入到`L`之后，`s`之前，也就是头节点的前面，顾名思义:**头插法**。

2. 插入数据为`2`的节点；

![img_v2_ce0d1031-39ee-494e-a207-8deeb999ef3g](https://images.waer.ltd/notes/202305071855043.jpg)

> 操作顺序如图①②所示：

```cpp
s->next = L->next; // ①
L->next = s;// ②
```

注意，在只有**一个标记**的节点中，①②的操作顺序是不能交换的，至于为什么后面会解释。

3. 依次创建待插入的数据`3,4,5,6`,操作步骤与第`2`步是一样的，`3`将插入到`2`的左边，成为下一个新的头节点，以此类推，后续元素值为`4,5,6`的节点都将执行同样的操作，轮流成为新的头节点，最终创建完成之后，`6`将成为链表的头节点，而最开始插入的元素值为`1`的节点将成为链表的尾节点。

![img_v2_4f0fe351-0954-4aa5-9bef-6e64130794eg](https://images.waer.ltd/notes/202305071907208.jpg)

**关于操作顺序的问题**

可以看到，其实上面使用头插法创建单链表的过程中，核心的两步就是:

```cpp
s->next = L->next; // ①
L->next = s;// ②
```

那么，这时候很多人开始晕了，为什么这个操作顺序不能改变？理解这点很重要。这直接决定了你能不能较好的理解后续链表中一些更为复杂的指向关系。

其实这里的顺序能否改变并不是死规定，它也有自己的条件，满足一定的条件即可无视顺序。否则只能牢记操作顺序。其实理解为什么要这样做，理解它这样做的原理才是最主要的！下面就分两种情况:有序和无序来解释。

- 有序

![img_v2_86c9ca5f-7115-4a81-900e-6f1b40ce91bg](https://images.waer.ltd/notes/202305071915371.jpg)
如图，如果你从上往下阅读到此，这图应该是很熟悉了才对。

~~注意看，视频中这名男子....~~不对。注意看，图片中元素值为`1`的右边节点，它是没有任何标记的节点，怎么理解这个 **标记**呢？

可以看到，`dummy`节点的`L`以及准备插入的元素值为`2`的新节点`s`，他们都有一个名称:`L`和`s`。这就是节点的**标记**，有了这个标记，我们可以直接获取到该节点的很多逻辑关系，比如，我知道了`s`节点，那么可以直接获取到它的下一个节点的地址指向关系为`s->next`，如果是双向链表，还可以获取到它的后继节点的前驱:`s->next->pre`等等。

那么与之相反的，没有标记的元素值为`1`的节点(这里假设称它为`1`节点)，如果要获取它的`next`该如何操作呢？可以借助已有的标记节点来间接的操作，比如:`L->next->next`就是1节点的`next`，显然，这种做法相对没那么直观，但这就是本质。如果一个节点没有任何标记，而我们又需要获取它的一些逻辑关系时，理解这一点很重要。

```cpp
s->next = L->next; // ①
L->next = s;// ②
```

> ①:正是因为`1`节点没有标记，所以才需要通过`L`来间接的表示它的指向关系。所以假设`1`节点现在有了一个标记为`k`的情况下，那么`①`就可以被简化为:``s->next = k``就如`②`中的`L->next = s`一般。

**如果一旦先执行了`②`,那么就会导致原来`L`节点的后面节点找不到的情况(因为此时``L->next`已经指向了`s`)，所以在有一端无标记的请联系，不能随意修改操作的顺序。**

- 无序

如果理解了上面 **有序**的情况，那么为什么可以无视操作顺序就不难理解。

![img_v2_2470ed0c-b247-49a1-a6e3-4ad2510887eg](https://images.waer.ltd/notes/202305071946189.jpg)

上图所表示的依旧是和[有序]情况中一样的逻辑，即将`s`节点插入到链表中的操作。不同的是，这里的`1`节点(元素值为`1`)的节点不再是一个孤独的无名野魂，它又了自己的名称(即上文所提到的**标记**)，所以可以通过其他节点间接完成的操作现在可以直接通过自己的标记`q`来完成，既然无论如何都能通过`q`来操作到该节点，也就不存在说找不到某个节点的情况，那么`①②`的顺序也就无所谓谁先谁后了，所以下面的两种指针操作都是可行的：

```cpp
L->next = s;
s->next = q;
```

```cpp
s->next = q;
L->next = s;
```

所以不出意外的话，你大概已经可以很清晰的理解无序有序的原理了。当然，世界总是充满着各种各样的惊喜，比如意外出现了，此时你惊奇的发现自己还是不理解，那有什么大不了的，**意大利面还可拌42号混凝土呢，换个职业也是卷啊哥！**。

****

**代码实现:**

```cpp
/**
 * 单链表的创建-头插法
 * @param L 单链表
 */
void CreateLinkList_H(LinkList &L)
{
    int n;
    LinkList s; // 定义一个指针变量
    L = new Node;
    L->next = nullptr; //创建一个空链表
    std::cout <<"请输入节点个数n:" <<std::endl;
    std::cin >> n;
    std::cout <<"请依次输入n个节点的值:" << std::endl;
    while (n--)
    {
        s = new Node; // 创建新节点s
        std::cin >> s->data; // 将输入的节点值赋给新节点的数据域data
        s->next = L->next;
        L->next = s; // 将新节点s插入到L节点之后
    }
}
```

##### 2.1.3.2**尾插法:**

与**头插法**不同，尾插法创建的链表，其输入的插入数据和链表的顺序是相同的，它每次会将新输入的节点插入到当前链表节点的后面，所以为了方便操作，我们需要定义一个尾节点指针来指向链表的尾部。

**图解:**

1. 初始化一个空链表，并将尾指针指向该节点。

![img_v2_e957b324-5522-40b2-acf3-7005107d9e3g](https://images.waer.ltd/notes/202305082152026.jpg)

2. 创建一个新的节点`s`，将数据赋给节点的数据域之后，将该节点插入到`L`的后面，并重新修改尾指针`R`的指向关系。

![img_v2_9384d845-4518-42f4-80c4-68fd786c85fg](https://images.waer.ltd/notes/202305082154266.jpg)

注意其中的`①②③`的顺序不能打乱：

① 将`s`节点的指针指向`nullptr`;

② 将链表的尾指针`R`指向新的尾节点`s`(将`s`节点的地址赋给`R`的指针域);

③ 将`s`节点的地址赋给`R`,完成为指针`R`新的指向关系；

```cpp
s->next = nullptr; //①
R->next = s;//②
R = s; //③
```

3. 输入下一个新的节点,以同样的原理插入到当前节点(节点值为`1`)的尾部；

![img_v2_af1f37bb-10e2-44e4-99c1-c22465c0592g](https://images.waer.ltd/notes/img_v2_af1f37bb-10e2-44e4-99c1-c22465c0592g.jpg)

4. 最终创建完成的单链表如下:

![img_v2_ad7e3dd1-9e81-4434-a7f8-b02b8f6ae38g](https://images.waer.ltd/notes/img_v2_ad7e3dd1-9e81-4434-a7f8-b02b8f6ae38g.jpg)

**代码实现:**

```cpp
/**
 * 单链表的创建-尾插法
 * @param L 单链表
 */
void CreateLinkList_R(LinkList &L)
{
    int n; //链表节点数量
    LinkList s,R;
    L = new Node;
    L->next = nullptr;
    R = L;
    std::cout <<"输入节点个数:" << std::endl;
    std::cin >> n;
    std::cout <<"依次输入n个元素:" << std::endl;
    while (n--)
    {
        s = new Node; // 创建新的节点
        std::cin >> s->data; // 给新节点赋值
        s->next = nullptr; // 将新节点的next指针域置空
        R->next = s; // 将新节点插入到当前节点之后
        R = s; // 完成尾指针的赋值，更新尾指针的指向
    }
}
```

****

#### 2.1.3取值(GetVal)

要在单链表中获取指定位置的值，这是一个比较麻烦的事情，相对于顺序表来说，单链表没有索引的概念，不能通过下标直接定位元素所在。

所以，在单链表中获取指定位置的值，需要从头节点开始，遍历整条链表，直到匹配到目标元素为止，原理就是这么点东西。

**算法步骤:**

- 定义指向头节点的移动指针`P`以及遍历链表所需的递增变量`j`,用来作为链表的计数器；
- 如果`P`不为空且`j<=i`则`P`指针继续后移，指向下一个节点，同时`j++`;
- 遍历终止的条件是:`P`为空或者`j==i`，即要么遍历链表结束后任没有找到目标元素所在位置，要么成功定位到目标元素，结束取值操作；

**图解:**

1. 移动指针`P`指向头节点且初始化`j=1`，表示从头节点开始查找；

![img_v2_e87d5efc-95d1-475f-a3ae-01650ab606cg](https://images.waer.ltd/notes/img_v2_e87d5efc-95d1-475f-a3ae-01650ab606cg.jpg)

2. 只要不满足查找结束的条件，则指针`P`将一直往后移动，计数器也随之递增；

![img_v2_e43ff7dd-7906-48dc-b2f9-9b21c37197dg](https://images.waer.ltd/notes/img_v2_e43ff7dd-7906-48dc-b2f9-9b21c37197dg.jpg)

3. 直到成功匹配到目标元素的位置，此时`j==i`，遍历结束；

![img_v2_e092f811-bf23-4804-afe0-5bb4239becfg](https://images.waer.ltd/notes/img_v2_e092f811-bf23-4804-afe0-5bb4239becfg.jpg)

> **为什么要使用一个额外的移动指针`P`？而不是直接使用链表的头节点？**
>
> - 头节点指针作为链表的标识，头节点指针不可以随意修改，一旦修改了头指针，有可能导致链表的不完整或者丢失，头指针就像女神手里的那条狗链。一旦女神松手了，那些走火入魔的添狗将会四处跑开，去挑下一个目标继续添，那么就导致女神的添狗服务不完整了。
> - 所以我们一般的做法是，如果涉及到头指针的使用，建议另外定义一个指针变量来作为临时指向，**不要直接修改头指针！不要直接修改头指针！**

**代码实现:**

```cpp
/**
 * 获取单链表中的第i个节点的数据
 * @param L 单链表
 * @param i 要获取元素的目标节点
 * @param v 暂存获取到的节点值
 * @return bool
 */
bool GetVal(LinkList L,int i,int &v)
{
    int j = 1;
    LinkList  p;
    p = L->next; // 将p指向头节点
    while (j<i && p)
    {
        p = p->next;
        j++;
    }
    if(!p || j>i)
        return false;
    v = p->data; //将目标值暂存到v中
    return true;
}
```

****

#### 2.1.4查找(LocateVal)

有了前面的基础，查找的原理理解起来就容易许多了，要查找链表是否存在值为`v`的节点，只需要定义一个移动指针`p`，开始指向头节点，依次将该节点的值目标值`v`进行匹配，若配对表示查找成功，返回即可。

否则，`p`指针继续往后一个节点移动，继续相同的比较操作，直到链表结束；

**图解：**

![img_v2_bdfc2c1f-7490-4d3a-8d7c-7d185f87d4ag](https://images.waer.ltd/notes/img_v2_bdfc2c1f-7490-4d3a-8d7c-7d185f87d4ag.jpg)

**代码实现:**

```cpp
/**
 * 删除单链表中的指定节点
 * @param L 单链表
 * @param i 指定节点
 * @return bool
 */
bool LocateVal(LinkList L,int v)
{
    LinkList p;
    p = L->next;
    while (p&&p->data != v)
        p = p->next;
    if(!p) // 到达链表尾部，查找失败
        return false;
    return true;
}
```

****

#### 2.1.5插入(InsertLinkList)

单链表的插入其实在前面创建单链表的过程中已经有所涉及。由于单链表没有索引的概念，所以如果需要在第`i`个节点之前插入一个新的节点， 那么可以找到链表的第`i-1`个节点，将新节点插入到`i-1`节点之后即可。

这是因为单链表只有指向后继的指向，所以不能从后向前进行操作，所以将新节点插入到`i-1`节点之后和`i`之前其实是同样的效果，不过是标书的方式不同罢了。

**算法步骤:**

- 定义操作指向`p`指向头节点，以及计数器`j=0`。
- 如果`p`不为空且`j<i-1`则将`p`继续后移到下一个节点的同时计数器递增；
- 直到`p`为空或者`j>=i-1`时停止；
- 将新节点插入到第`i-1`和节点之后即可；

**图解：**

![img_v2_86099184-96ac-4a3f-8eff-fafcc3a1214g](https://images.waer.ltd/notes/img_v2_86099184-96ac-4a3f-8eff-fafcc3a1214g.jpg)

> 由于这里的插入操作①②和前面创建单链表的园路是一样的，所以不再赘述。

**代码实现:**

```cpp
/**
 * 在单链表的第i个节点之前插入目标节点值v
 * @param L 单链表
 * @param i 插入位置
 * @param v 待插入的值
 * @return bool
 */
bool InsertLinkList(LinkList &L,int i,int v)
{
    int j=0;
    LinkList p,s;
    p = L;
    while (p && j<i-1)
    {
        p = p->next;
        j++;
    }
    if (!p || j>i-1) //i>n+1 or i<1 插入位置不合法
        return false;
    s = new Node;
    s->data = v;
    s->next = p->next;
    p->next = s;
    return true;
}
```

****

#### 2.1.6删除(DeleteLinkList)

单链表的删除原理比较简单，要删除某个节点，只需要将该节点跳过即可。所以，欲删除第`i`个节点，那就必须先定位到`i-1`个节点，将该位置节点的指向指向`i`的下一个节点，即`i+1`即可，再通过`delete`释放`i`位置处的空间即可完成删除操作。

![img_v2_c5e7943d-807b-4fb6-9bbf-c427ccdc6abg](https://images.waer.ltd/notes/img_v2_c5e7943d-807b-4fb6-9bbf-c427ccdc6abg.jpg)

根据上面的原理，我们只需将`p`节点的指针指向待删除的`q`节点的下一个节点地址即可，所以，这段逻辑体现在具体的代码上就是:

```cpp
p->next = q->next;
```

此时将不再有任何指向节点`q`的指针，她已经和链表断开了联系，不再是链表的一分子了，但这个节点任然在内存空间中占有一席之地，所以我们还需要将它所拥有的那部分内存释放，这样才是完全将其从链表中删除掉。

```cpp
delete q;
```

**代码实现:**

```cpp
/**
 * 删除单链表中的指定节点
 * @param L 单链表
 * @param i 指定节点
 * @return bool
 */
bool DeleteLinkList(LinkList &L,int i)
{
    LinkList p,q;
    int j=0;
    p = L;
    while ((p->next)&& (j<i-1))
    {
        p = p->next;
        j++;
    }
    if(!(p->next) || (j>i-1))
        return false;
    q = p->next; //将待删除的节点地址暂存到q里，以备后续的内存释放
    p->next = q->next;
    delete q; // 释放被删除节点的内存空间
    return true;
}
```

****

### 3、双链表

见名知意，和单链表类似，双链表的 **双** 指的是链表中每个节点上的地址指针个数。

所以，双链表就是在单链表的基础上，新增了一个指向前一个节点地址的指针`precursor `(为了方便，后续涉及到的链表前一个节点指针均用缩写`pre`代指)。

也即是说，一个完整的双链表节点的构成元素如下:

- 指向前一个节点地址的指针，即**前驱指针(`pre`)**；
- 节点的值；
- 指向后一个节点地址的指针，即**后继指针(`next`)**；

![img_v2_668b63ad-32e4-4060-9a33-97a3e5b54f2g](https://images.waer.ltd/notes/img_v2_668b63ad-32e4-4060-9a33-97a3e5b54f2g.jpg)

明白结构之后，如何定义一个双链表就不难了，下面是其中一种实现参考:

```cpp
typedef int ElemType;
typedef struct Node
{
    ElemType data;
    struct Node *pre,*next;
} Node,*DoubleLinkList;
```

****

#### 3.1双链表的基本操作

##### 3.1.2 初始化(InitDoubleLinkList)

初始化会创建一个空的双链表，链表的节点不存储任何值且前驱后继指针均为`nullptr`。

```cpp
/**
 * 双链表的初始化
 * @param L 双链表
 * @return bool
 */
bool InitDoubleLinkList(DoubleLinkList &L)
{
    L = new Node;
    if(!L)
        return false;
    L->pre = L->next = nullptr; //置空前驱与后继指针
    return true;
}

```

****

##### 3.1.3 创建(CreateDoubleLinkList_H)

和单链表一样，双链表也支持头插和尾插法两种方式创建链表。以头插法为例，头插法的特点是，该方法创建的链表和数据输入的顺序是相反的，所以也称为 **逆序建表**。同理，尾插法也称为 **正序建表**。

**算法步骤:**

- 初始化一个空表，节点无值，前后指针指向`nullptr`
- 创建一个新的待插入节点并为节点赋值。
- 将新节点插入到头节点的后面，更新指针的指向关系。

**图解:**

1. 创建头节点以及待插入的新节点；

```cpp
s = new Node;
cin >> s->data;
```

![img_v2_76d82c55-80c9-4874-98f6-13afeb683b0g](https://images.waer.ltd/notes/img_v2_76d82c55-80c9-4874-98f6-13afeb683b0g.jpg)

2. 将值为1的新节点插入到头节点的后面；

```cpp
s->next = L->next;
L->next = s;
s->pre = L;
```

![img_v2_3ffe25e1-d76a-4a58-bbbf-ce8e81211f3g](https://images.waer.ltd/notes/img_v2_3ffe25e1-d76a-4a58-bbbf-ce8e81211f3g.jpg)

3. 新增值为2的节点并插入到头节点之后，也就是上一个值为1的节点之前；

```cpp
s->next = L->next; // ①先找到s的后继
L->next->pre = s; // ②再找到后继的前驱
s->pre = L; // ③找到s的前驱
L->next = s; // ④指向L的后继
```

![img_v2_29083761-b75f-40bb-934e-b907bc4d389g](https://images.waer.ltd/notes/img_v2_29083761-b75f-40bb-934e-b907bc4d389g.jpg)

上面的顺序中，前三步的顺序是不随意调换的，这是因为当插入值为2的节点时，之前第一个插入的值为1的节点已经没有了指针标记(此时的指针标记`s`已经指向了当前插入的节点，也就是值为2的节点之上)。

> 不能调换顺序的原因是因为节点的指针是相互关联的，如果改变了插入节点的位置和指针的指向顺序，就会导致链表结构的错误，甚至会造成内存泄漏等问题。因此，在插入新节点时，必须按照一定的顺序来设置节点的指针，以保证链表结构的正确性。

所以我们需要以待插入的节点`s`为核心，将s的后继指向**没有标记**的节点，如此一来便将s和 **无标记**节点建立了联系。

完成了①之后，第②步也就情理之中了，在完成了节点`s`的后继关联之后，继续以`s`为核心，所以首先操作的应该是`s`指出去的指针，也即是第③步骤中的操作，再来完成第④步骤也就情理之中，顺理成章的事。

这里可能很多人在初学的时候会被绕懵逼，但其实只要明白**核心节点**是指当前需要插入的节点，**无标记节点**是指与核心节点相邻且不是头节点的节点。

清晰理解这两个节点之后，再按照上面的逻辑处理就很容易理解。

**代码实现:**

```cpp
void CreateDoubleLinkList_H(DoubleLinkList &L)
{
    DoubleLinkList s;
    int n;
    L = new Node;
    L->pre = L->next = nullptr;
    std::cout <<"Enter the number of elements" << std::endl;
    std::cin >> n;
    while (n--)
    {
        s = new Node;
        std::cin >> s->data;
        if (L->next)
            L->next->pre = s; //注意，如果L有下一个节点，就直接指向这一步即可
        s->next = L->next;
        s->pre = L;
        L->next = s;
    }
}
```

****

##### 3.1.4 插入(InsertDoubleLinkList)

回忆前面单链表的插入原理，在单链表中的第`i`个位置插入一个新节点，我们需要找到前一个节点`i-1`的位置。那是因为单链表不存在指向前面节点的前驱指针`pre`，所以在双链表中，我们可以直接找到第`i`个位置(假设存在第`i`个节点)，从而将新节点直接插入到第`i`个位置之前。

> 注意:以上情况是在假设第`i`个位置存在的前提下的，若假设不成立且第`i-1`个位置存在的话，还是需要找到该位置然后将新节点插入到`i-1`节点之后，原理就和单链表的插入无异了。

**图解:**

如下图，假设插入的节点值为`v`,要将其插入到双链表`p`中，具体的插入逻辑如下:

![img_v2_1237c8c9-fc7c-4c83-8ef2-15fa5acb03fg](https://images.waer.ltd/notes/img_v2_1237c8c9-fc7c-4c83-8ef2-15fa5acb03fg.jpg)

> 注意，上述三个节点中，第一个节点(`p->pre`)是没有任何标记的，所以不能轻易修改这个节点指针(p的前驱)，因此将其留到最后操作。

理解了 **注意** 之后，其余的`①②③`步的顺序就没有固定的写法了，先操作那一步其实无所谓，但为了方便记忆与理解，这里还是按照上面所说的 **以核心节点为主，先修改无标记节点** 的步骤去操作，那么上图代码实现为:

```cpp
s->pre = p->pre; // ①
p-pre->next = s; //②
s->next = p; // ③
p->pre = s; //④
```

**代码实现:**

```cpp
/**
 * 双链表的插入
 * @param L 双链表
 * @param i 第i个节点
 * @param v 插入节点的值
 * @return bool
 */
bool InsertDoubleLinkList(DoubleLinkList &L,int i,int v)
{
    DoubleLinkList p, s;
    int j=0;
    p = L;
    while (p && j<i)
    {
        p = p->next;
        j++;
    }
    if ( !p || j >i) return false;
    s = new Node;
    s -> data = v;
    // 下面是核心的4步:
    s -> pre = p->pre;
    p -> pre->next = s;
    s -> next = p;
    p -> pre = s;
    return true;
}
```

****

##### 3.1.5 删除(InsertDoubleLinkList)

由于存在前驱后继双指针，所以双链表的删除也是很方便，只需要找到待删除的节点`i`的位置，将前后指针的指向分别跳过`i`节点，然后删除节点`i`的内存即可完成删除。

**图解:**

![img_v2_cc6567d6-ce39-4ba7-9462-d1de7f34b51g](https://images.waer.ltd/notes/img_v2_cc6567d6-ce39-4ba7-9462-d1de7f34b51g.jpg)

如图，要删除节点`p`，只需要将`p`节点的前一个指针的后继直接指向`p`的后继节点以及`p`节点的后继的前驱直接指向`p`的前驱节点即可完成删除节点的跳过。

再将`p`节点的内存空间清理掉之后删除就完成了。

注意，这里对于步骤`①②`来说是没有先后顺序的，不要被图示迷惑，图标记了步骤只是为了更好的说明。

```cpp
p->pre->next = p->next; // ①
p->next->pre = p->pre; // ②
```

> 上面的操作是在基于后继节点存在的前提下，如果这个条件不成立，那么就没必要执行`②`了。

**代码实现:**

```cpp
/**
 * 删除指定节点
 * @param L 双链表
 * @param i 要删除的第i个节点
 * @return bool
 */
bool DeleteDoubleLinkList(DoubleLinkList &L,int i)
{
    DoubleLinkList p;
    int j = 0;
    p = L;
    while (p && j < i)
    {
        p = p->next;
        j++;
    }
    if (!p || j > i) return false;
    if (p->next)
        p->next->pre = p->pre;
    p->pre->next = p->next;
    delete p;
    return true;
}
```

****

### 4、循环链表

循环链表的定义很简单，就是链表不存在逻辑意义上的尾节点。下面是对于循环链表测一些定义：

**循环单链表:**

> 单链表的最后一个节点的后继指针不指向`nullptr`，而是指向头节点`L`，以此构成一个封闭的环结构。

![img_v2_b1b2f6e2-1ea4-4ffc-88e5-47237ab852fg](https://images.waer.ltd/notes/img_v2_b1b2f6e2-1ea4-4ffc-88e5-47237ab852fg.jpg)

注意，由于循环链表的结构特征，在对于链表判空的条件上也需要有所改变:

```cpp
L->next = L;
```

**循环双链表:**

> 同理于循环单链表，循环双链表则是将最后一个节点的后继指向头节点，因为还存在前驱节点指向，所以还需要将头节点的前驱也指向最后一个节点，以此成环。

![img_v2_68fc79c3-cf15-4211-b993-6e1d74ae058g](https://images.waer.ltd/notes/img_v2_68fc79c3-cf15-4211-b993-6e1d74ae058g.jpg)

循环双链表的判空条件如下:

```cpp
L->next = L->pre = L;
```

****

### 5、顺序表VS链表

![image-20230524211715138](https://images.waer.ltd/notes/image-20230524211715138.png)

****

### 刷题实战

> 后续独立更新....

****

## 3、栈与队列

**栈**是一种数据元素**先进后出**的结构，所谓栈，其本质也还是一种线性表，但在操作上，栈只能在线性表的一端进行。

基于不同的存储方式，栈可以分为**顺序栈和链栈**。

在栈结构中，数据元素进出的一段称为**栈顶**，另一端称为**栈底**。

****

### 3.1 顺序栈的基本操作

所谓顺序栈，就是使用顺序表作为基本的存储结构实现而来。为了实现栈的基本特性以及操作流程，使用顺序表实现栈我们需要定义两个指针分别指向栈顶和栈底，不妨就是`*top`和`*base`。

![img_v2_a6b039e0-17b0-44ff-998a-29c44800354g](https://images.waer.ltd/notes/img_v2_a6b039e0-17b0-44ff-998a-29c44800354g.jpg)

**结构体定义**

```cpp
const int MaxSize = 100;
typedef int ElemType;
typedef struct SqStack
{
    ElemType *Base; // 栈底指针
    ElemType *Top; // 栈顶指针
} SqStack;
```

#### 3.1.1 初始化

栈的初始化，创建一个栈底栈顶指针均指向栈栈底的预设大小的空栈；

![img_v2_48ea2040-7317-4fd6-87c9-32280aa9244g](https://images.waer.ltd/notes/img_v2_48ea2040-7317-4fd6-87c9-32280aa9244g.jpg)

**代码实现:**

```cpp
/**
 * 初始化
 * @param s 栈
 * @return bool
 */
bool InitStack(SqStack &s)
{
    s.Base = new ElemType[MaxSize];
    if (!s.Base)
        return false;
    s.Top = s.Base; 
    return true;
}
```

****

#### 3.1.2 入栈

也称为压栈，就是将新元素插入到栈中，当然，本着栈**先进后出**的特性，新压入栈的元素存在于栈底，之后将栈顶指针`*Top`上移。注意入栈之前判断栈的状态是否为满栈。

![img_v2_f9b3b715-cb7f-4f27-8b2f-29c7785d683g](https://images.waer.ltd/notes/img_v2_f9b3b715-cb7f-4f27-8b2f-29c7785d683g.jpg)

**代码实现:**

```cpp
/**
 * 入栈
 * @param S 栈
 * @param v 如栈元素
 * @return bool
 */
bool Push(SqStack &S,int v)
{
    if (S.Top - S.Base == MaxSize) // 满栈状态，不能继续入栈
        return false;
    *S.Top++=v; // 将元素入栈且完成Top指针的上移
    return true;
}
```

****

#### 3.1.3 出栈

将元素从栈内取出的操作，首先判断栈的存储状态是否为空栈，不为空时才可以进行出栈操作(为空时出什么?空气?)，然后剑弹出的值赋给栈顶指针并将指针下移。

![img_v2_428a7ba9-2a10-423e-a49e-11aba2be70dg](https://images.waer.ltd/notes/img_v2_428a7ba9-2a10-423e-a49e-11aba2be70dg.jpg)

**代码实现:**

```cpp
/**
 * 出栈
 * @param S 栈
 * @param e 出栈元素
 * @return bool
 */
bool Pop(SqStack &S,int &v)
{
    if (S.Base == S.Top) // 栈空
        return false;
    v = *--S.Top;
    return true;
}
```

****

#### 3.1.4 取栈顶元素

顾名思义就是取出栈顶的元素，注意和出栈的区别。去栈顶指的是将栈顶元素的值取出返回，此时栈中依旧存在该栈顶，不需要删除，自然也无需移动`*Top`指针，而出栈是将栈顶元素直接从栈中移除并更新栈顶指针`*Top`。

![img_v2_ca62926a-db8d-4ca1-90e6-2e615b23d33g](https://images.waer.ltd/notes/img_v2_ca62926a-db8d-4ca1-90e6-2e615b23d33g.jpg)

**代码实现:**

```cpp
/**
 * 获取栈顶元素
 * @param S 栈
 * @return int
 */
int GetTop(SqStack S)
{
    if (!IsEmpty(S)) 
        return *(S.Top - 1);
    else
        return -1;
}
```

为了方便复用，这里直接将栈空和栈满的判断也写成独立的方法,但上面文档中已经写好的代码就不再变动，只调整项目代码。

```cpp
/**
 * 是否空栈
 * @param S 栈
 * @return bool
 */
bool IsEmpty(SqStack S)
{
    return S.Base == S.Top;
}

/**
 * 是否满栈
 * @param S 栈
 * @return bool
 */
bool IsFull(SqStack S)
{
    return S.Top - S.Base == MaxSize;
}
```

****

### 3.2 链栈的基本操作

链栈：就是使用链式结构实现的栈。和单链表同理，由于链式结构的地址不像顺序表那样有连续空间，因此定义链栈的结构时只需要定义一个栈顶指针即可。

在链栈中，新的栈元素将被插入到栈顶，其实也就是在一个没有头指针的单链表的头部进行插入操作。

![img_v2_f91ec68a-d0b5-48f1-b13f-420deec2213g](https://images.waer.ltd/notes/img_v2_f91ec68a-d0b5-48f1-b13f-420deec2213g.jpg)

所以，我们可以如下定义链栈的结构：

```cpp
typedef int ElemType;
typedef struct LkStack
{
    ElemType data;
    struct LkStack *Top; // 也就是上图中的next指针
} LkStack,*LinkStack;
```

****

#### 3.2.1 初始化

创建一个栈顶指针指向`nullptr`的节点；

**代码实现:**

```cpp
/**
 * 初始化
 * @param S 栈
 * @return bool
 */
bool InitStack(LinkStack &S)
{
    S = nullptr;
    return true;
}
```

****

#### 3.2.2 入栈

