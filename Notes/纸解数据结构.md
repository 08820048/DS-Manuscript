# 纸解数据结构

## 前言？

数据结构是指数据元素之间的关系，以及这些关系在计算机中的储存和操作方式。数据结构可以分为线性结构、树结构、图结构等，不同的数据结构适用于不同的应用场景。常见的数据结构有数组、链表、栈、队列、树、图等。在计算机科学中，数据结构是算法的基础，是处理数据的关键。

但这篇文章的目的不在于去扣很多的理论内容，而是直截了当的通过画图结合的方式展现数据结构的基础操作以及代码演示，所以，这篇文章并**不适合用来作为应考**的小册子，更多的是学习数据结构的**实战与基本原理**。

个人也是学习者，能力有限，其中不乏有错误遗漏之处，欢迎指正！

代码使用C++语言。

****

## 纸解？

这个是我自己的定义，就是通过纸张手稿画图的形式展现数据结构，本来想通过`iPad`手绘的形式展现的，无奈贫穷封印了我的`iPad`，所以就只能通过草稿纸草图了，图纸中涉及到的图与字可能比较抽象，凑合看看。

****

## 纸解顺序表

### 顺序表的基本操作

结构体定义:

```cpp
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;
```



> - 初始化
> - 创建
> - 取值
> - 查找
> - 插入
> - 删除
>
> 复杂度分析。

#### 初始化(InitList)

初始化就是为顺序表分配一个预定的表长(假设为`MaxSize`)。那么就用`new`关键字给表分配一个预定大小的空间，若分配成功返回空间的首地址，否则返回空指针(nullptr)用val记录这段空间的基地址，由于初始化时表中没有元素，所以元素的实际长度length为0。

**纸解:**

![a1fc4acab7d3485a3d62068de427703](https://images.waer.ltd/notes/202305031819552.jpg)

**代码实现:**

```cpp
/**
 * 初始化顺序表
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}
```

**含测试:**

```cpp
/**
* Author: 八尺妖剑
* Date: 2023/5/3
* Email: iliekxff@gmail.com
* Blog: https://waer.ltd
* Desc: 顺序表的基本操作
**/

#include <iostream>
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;

bool InitList(SqlList &L);

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    for(int i=0;i<10;i++)
    {
        L.val[i] = i+1;
        L.length++;
    }

    cout << "插入10个元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    delete[] L.val;

    return 0;
}

/**
 * 初始化顺序表
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}
```

> 初始化成功!
> 插入10个元素之后，顺序表的长度:10
> 顺序表的元素为:
> 1 2 3 4 5 6 7 8 9 10

****

#### 创建(CreateList)

即向初始化好的顺序表中依次添加数据元素。

**算法步骤:**

- 初始化索引变量`i=0`，判断顺序表是否表满，是则结束，否则继续;
- 输入数据元素`x`;
- 将数据存入顺序表的第`i`个位置，即`L.val[i] = x`,然后递增索引`i`。
- 顺序表长度递增。
- 完成创建。

下面的图解步骤以向顺序表中添加`5,3,6`为例：
![a816fd51d71eaedb8eafc3d5aa87873](https://images.waer.ltd/notes/202305031826109.jpg)

![59dcbede862a24bdb13c9e8106865e1](https://images.waer.ltd/notes/202305031827712.jpg)

![77069055d9c8a363fcaa792c5bcddd7](https://images.waer.ltd/notes/202305031827326.jpg)

**代码实现:**

```cpp
/**
 * 顺序表的创建
 * @param L 顺序表的引用
 * @return bool
 */
bool CreateList(SqlList &L)
{
    int i = 0,x=0;
    std::cin >> x;
    while(x!=-1) //代表输入-1时结束输入
    {
        if(L.length == MaxSize)
        {
            std::cout <<"哦吼！表满了。";
            return false;
        }
        L.val[i++] = x; // #3 向顺序表添加元素并递增索引
        L.length++; //#4 长度递增
        std::cin >> x;
    }
    return true;
}
```

**含测试:**

```cpp
/**
* Author: 八尺妖剑
* Date: 2023/5/3
* Email: iliekxff@gmail.com
* Blog: https://waer.ltd
* Desc: 顺序表的基本操作
**/

#include <iostream>
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;

bool InitList(SqlList &L);
bool CreateList(SqlList &L);
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    // 测试创建函数
    if (!CreateList(L))
    {
        cout <<"创建失败!" << endl;
    }
    cout <<"创建成功!" << endl;
    cout << "插入3个元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    delete[] L.val;

    return 0;
}

/**
 * 顺序表的初始化
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}


/**
 * 顺序表的创建
 * @param L 顺序表的引用
 * @return bool
 */
bool CreateList(SqlList &L)
{
    int i = 0,x=0;
    std::cin >> x;
    while(x!=-1) //输入-1时结束输入
    {
        if(L.length == MaxSize)
        {
            std::cout <<"哦吼！表满了。";
            return false;
        }
        L.val[i++] = x; // #3 向顺序表添加元素并递增索引
        L.length++; //#4 长度递增
        std::cin >> x;
    }
    return true;
}
```

> [------------------初始化函数测试---------------]
> 初始化成功!
> [------------------创建函数测试---------------]
> 5
> 3
> 9
> -1
> 创建成功!
> 插入3个元素之后，顺序表的长度:3
> 顺序表的元素为:
> 5 3 9 

****

#### 取值(GetVal)

根据指定的索引`i`返回对应得到元素值`v`。

**算法步骤:**

- 索引合法性判断(是否超出上下界)；
- 将第`i`处位置对应的元素值`val[i-1]`赋给`v`;
- 返回`true`，方法结束。

> 注意索引和位置的关系，这里所说的位置是指在顺序表中的第几个元素，而索引是顺序表的下标序号，位置和索引差1(即索引+1=位置)，因此，我们要获取第i个位置的元素，其实就是val[i-1]处的元素。

**图解:**

![25f987744047a1a439dc67576185dfc](https://images.waer.ltd/notes/202305031855859.jpg)

**代码实现:**

```cpp
/**
 * 获取第n个元素
 * @param L 表引用
 * @param i 位置
 * @param v 存储获取到的元素值的引用
 * @return bool
 */
bool GetVal(SqlList &L,int i,int &v)
{
    for (i <1 || i > L.length)
    {
        std::cout <<"非法位置";
        return false;
    }
    v = L.val[i-1]；
    return true;    
}
```

**含测试:**

```cpp
/**
* Author: 八尺妖剑
* Date: 2023/5/3
* Email: iliekxff@gmail.com
* Blog: https://waer.ltd
* Desc: 顺序表的基本操作
**/

#include <iostream>
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;

void TestPrint(const std::string &str);
bool InitList(SqlList &L);
bool CreateList(SqlList &L);
bool GetVal(SqlList &L,int i,int &v);
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    TestPrint("------------------初始化函数测试---------------");
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    // 测试创建函数
    TestPrint("------------------创建函数测试---------------");
    if (!CreateList(L))
    {
        cout <<"创建失败!" << endl;
    }
    cout <<"创建成功!" << endl;

    cout << "插入3个元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    // 测试获取元素函数
    TestPrint("------------------获取函数测试---------------");
    int v;
    if (!GetVal(L,3,v))
    {
        cout <<"获取失败!";
    }
    cout <<"第" << 3 << "个位置的元素为:" << v <<endl;
    delete[] L.val;

    return 0;
}

void TestPrint(const std::string &str)
{
    std::cout << "[" <<str <<"]" << std::endl;
}



/**
 * 顺序表的初始化
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}


/**
 * 顺序表的创建
 * @param L 顺序表的引用
 * @return bool
 */
bool CreateList(SqlList &L)
{
    int i = 0,x=0;
    std::cin >> x;
    while(x!=-1) //代表输入-1时结束输入
    {
        if(L.length == MaxSize)
        {
            std::cout <<"哦吼！表满了。";
            return false;
        }
        L.val[i++] = x; // #3 向顺序表添加元素并递增索引
        L.length++; //#4 长度递增
        std::cin >> x;
    }
    return true;
}


/**
 * 获取第n个元素
 * @param L 表引用
 * @param i 位置
 * @param v 存储获取到的元素值的引用
 * @return bool
 */
bool GetVal(SqlList &L,int i,int &v)
{
    if (i < 1 || i > L.length)
    {
        std::cout <<"非法位置";
        return false;
    }
    v = L.val[i-1];
    return true;
}
```

> [------------------初始化函数测试---------------]
> 初始化成功!
> [------------------创建函数测试---------------]
> 5
> 3
> 9
> -1
> 创建成功!
> 插入3个元素之后，顺序表的长度:3
> 顺序表的元素为:
> 5 3 9 
> [------------------取值函数测试---------------]
> 第3个位置的元素为:9

****

#### 查找(LocateVal)





#### 插入(ListInsert)





#### 删除(ListDelete)



