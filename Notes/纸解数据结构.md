# 纸解数据结构

## 前言？

数据结构是指数据元素之间的关系，以及这些关系在计算机中的储存和操作方式。数据结构可以分为线性结构、树结构、图结构等，不同的数据结构适用于不同的应用场景。常见的数据结构有数组、链表、栈、队列、树、图等。在计算机科学中，数据结构是算法的基础，是处理数据的关键。

但这篇文章的目的不在于去扣很多的理论内容，而是直截了当的通过画图结合的方式展现数据结构的基础操作以及代码演示，所以，这篇文章并**不适合用来作为应考**的小册子，更多的是学习数据结构的**实战与基本原理**。

个人也是学习者，能力有限，其中不乏有错误遗漏之处，欢迎指正！

代码使用C++语言。

****

## 纸解？

这个是我自己的定义，就是通过纸张手稿画图的形式展现数据结构，本来想通过`iPad`手绘的形式展现的，无奈贫穷封印了我的`iPad`，所以就只能通过草稿纸草图了，图纸中涉及到的图与字可能比较抽象，凑合看看。

****

## 纸解顺序表

### 顺序表的基本操作

结构体定义:

```cpp
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;
```



> - 初始化
> - 创建
> - 取值
> - 查找
> - 插入
> - 删除
>
> 复杂度分析。

#### 初始化(InitList)

初始化就是为顺序表分配一个预定的表长(假设为`MaxSize`)。那么就用`new`关键字给表分配一个预定大小的空间，若分配成功返回空间的首地址，否则返回空指针(nullptr)用val记录这段空间的基地址，由于初始化时表中没有元素，所以元素的实际长度length为0。

**纸解:**

![a1fc4acab7d3485a3d62068de427703](https://images.waer.ltd/notes/202305031819552.jpg)

**代码实现:**

```cpp
/**
 * 初始化顺序表
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}
```

**含测试:**

```cpp
/**
* Author: 八尺妖剑
* Date: 2023/5/3
* Email: iliekxff@gmail.com
* Blog: https://waer.ltd
* Desc: 顺序表的基本操作
**/

#include <iostream>
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;

bool InitList(SqlList &L);

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    for(int i=0;i<10;i++)
    {
        L.val[i] = i+1;
        L.length++;
    }

    cout << "插入10个元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    delete[] L.val;

    return 0;
}

/**
 * 初始化顺序表
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}
```

> 初始化成功!
> 插入10个元素之后，顺序表的长度:10
> 顺序表的元素为:
> 1 2 3 4 5 6 7 8 9 10

****

#### 创建(CreateList)

即向初始化好的顺序表中依次添加数据元素。

**算法步骤:**

- 初始化索引变量`i=0`，判断顺序表是否表满，是则结束，否则继续;
- 输入数据元素`x`;
- 将数据存入顺序表的第`i`个位置，即`L.val[i] = x`,然后递增索引`i`。
- 顺序表长度递增。
- 完成创建。

下面的图解步骤以向顺序表中添加`5,3,6`为例：
![a816fd51d71eaedb8eafc3d5aa87873](https://images.waer.ltd/notes/202305031826109.jpg)

![59dcbede862a24bdb13c9e8106865e1](https://images.waer.ltd/notes/202305031827712.jpg)

![77069055d9c8a363fcaa792c5bcddd7](https://images.waer.ltd/notes/202305031827326.jpg)

**代码实现:**

```cpp
/**
 * 顺序表的创建
 * @param L 顺序表的引用
 * @return bool
 */
bool CreateList(SqlList &L)
{
    int i = 0,x=0;
    std::cin >> x;
    while(x!=-1) //代表输入-1时结束输入
    {
        if(L.length == MaxSize)
        {
            std::cout <<"哦吼！表满了。";
            return false;
        }
        L.val[i++] = x; // #3 向顺序表添加元素并递增索引
        L.length++; //#4 长度递增
        std::cin >> x;
    }
    return true;
}
```

**含测试:**

```cpp
/**
* Author: 八尺妖剑
* Date: 2023/5/3
* Email: iliekxff@gmail.com
* Blog: https://waer.ltd
* Desc: 顺序表的基本操作
**/

#include <iostream>
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;

bool InitList(SqlList &L);
bool CreateList(SqlList &L);
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    // 测试创建函数
    if (!CreateList(L))
    {
        cout <<"创建失败!" << endl;
    }
    cout <<"创建成功!" << endl;
    cout << "插入3个元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    delete[] L.val;

    return 0;
}

/**
 * 顺序表的初始化
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}


/**
 * 顺序表的创建
 * @param L 顺序表的引用
 * @return bool
 */
bool CreateList(SqlList &L)
{
    int i = 0,x=0;
    std::cin >> x;
    while(x!=-1) //输入-1时结束输入
    {
        if(L.length == MaxSize)
        {
            std::cout <<"哦吼！表满了。";
            return false;
        }
        L.val[i++] = x; // #3 向顺序表添加元素并递增索引
        L.length++; //#4 长度递增
        std::cin >> x;
    }
    return true;
}
```

> [------------------初始化函数测试---------------]
> 初始化成功!
> [------------------创建函数测试---------------]
> 5
> 3
> 9
> -1
> 创建成功!
> 插入3个元素之后，顺序表的长度:3
> 顺序表的元素为:
> 5 3 9 

****

#### 取值(GetVal)

根据指定的索引`i`返回对应得到元素值`v`。

**算法步骤:**

- 索引合法性判断(是否超出上下界)；
- 将第`i`处位置对应的元素值`val[i-1]`赋给`v`;
- 返回`true`，方法结束。

> 注意索引和位置的关系，这里所说的位置是指在顺序表中的第几个元素，而索引是顺序表的下标序号，位置和索引差1(即索引+1=位置)，因此，我们要获取第i个位置的元素，其实就是val[i-1]处的元素。

**图解:**

![25f987744047a1a439dc67576185dfc](https://images.waer.ltd/notes/202305031855859.jpg)

**代码实现:**

```cpp
/**
 * 获取第n个元素
 * @param L 表引用
 * @param i 位置
 * @param v 存储获取到的元素值的引用
 * @return bool
 */
bool GetVal(SqlList &L,int i,int &v)
{
    for (i <1 || i > L.length)
    {
        std::cout <<"非法位置";
        return false;
    }
    v = L.val[i-1]；
    return true;    
}
```

**含测试:**

```cpp
/**
* Author: 八尺妖剑
* Date: 2023/5/3
* Email: iliekxff@gmail.com
* Blog: https://waer.ltd
* Desc: 顺序表的基本操作
**/

#include <iostream>
const int MaxSize = 100;
typedef int ElemType;
typedef struct
{
    ElemType *val;
    int length;
} SqlList;

void TestPrint(const std::string &str);
bool InitList(SqlList &L);
bool CreateList(SqlList &L);
bool GetVal(SqlList &L,int i,int &v);
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    TestPrint("------------------初始化函数测试---------------");
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    // 测试创建函数
    TestPrint("------------------创建函数测试---------------");
    if (!CreateList(L))
    {
        cout <<"创建失败!" << endl;
    }
    cout <<"创建成功!" << endl;

    cout << "插入3个元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    // 测试获取元素函数
    TestPrint("------------------获取函数测试---------------");
    int v;
    if (!GetVal(L,3,v))
    {
        cout <<"获取失败!";
    }
    cout <<"第" << 3 << "个位置的元素为:" << v <<endl;
    delete[] L.val;

    return 0;
}

void TestPrint(const std::string &str)
{
    std::cout << "[" <<str <<"]" << std::endl;
}



/**
 * 顺序表的初始化
 * @param L 顺序表的引用
 * @return bool
 */
bool InitList(SqlList &L)
{
    L.val = new int[MaxSize]; // 动态分配一个MaxSize大小的空间
    if (!L.val) return false; //分配失败
    L.length = 0; //将长度初始化为0
    return true; // 分配成功
}


/**
 * 顺序表的创建
 * @param L 顺序表的引用
 * @return bool
 */
bool CreateList(SqlList &L)
{
    int i = 0,x=0;
    std::cin >> x;
    while(x!=-1) //代表输入-1时结束输入
    {
        if(L.length == MaxSize)
        {
            std::cout <<"哦吼！表满了。";
            return false;
        }
        L.val[i++] = x; // #3 向顺序表添加元素并递增索引
        L.length++; //#4 长度递增
        std::cin >> x;
    }
    return true;
}


/**
 * 获取第n个元素
 * @param L 表引用
 * @param i 位置
 * @param v 存储获取到的元素值的引用
 * @return bool
 */
bool GetVal(SqlList &L,int i,int &v)
{
    if (i < 1 || i > L.length)
    {
        std::cout <<"非法位置";
        return false;
    }
    v = L.val[i-1];
    return true;
}
```

> [------------------初始化函数测试---------------]
> 初始化成功!
> [------------------创建函数测试---------------]
> 5
> 3
> 9
> -1
> 创建成功!
> 插入3个元素之后，顺序表的长度:3
> 顺序表的元素为:
> 5 3 9 
> [------------------取值函数测试---------------]
> 第3个位置的元素为:9

****

#### 查找(LocateVal)

在顺序表中查找指定元素v。

从头遍历顺序表，依次比较元素是否等于指定值，是则返回其索引，否则返回-1.

**代码实现:**

```cpp
/**
 * 查找指定元素
 * @param L  顺序表
 * @param v 指定元素
 * @return 成功返回元素索引，失败返回-1
 */
int  LocateVal(SqlList L,int v)
{
    int i;
    for(i=0;i<L.length;i++)
    {
        if (L.val[i] == v) return i;
    }
    return -1;
}
```

**含测试:**

```cpp
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    //测试初始化函数
    TestPrint("------------------初始化函数测试---------------");
    SqlList L;
    if (!InitList(L))
        cout <<"初始化失败!" << endl;
    cout << "初始化成功!" << endl;
    // 测试创建函数
    TestPrint("------------------创建函数测试---------------");
    if (!CreateList(L))
    {
        cout <<"创建失败!" << endl;
    }
    cout <<"创建成功!" << endl;

    cout << "插入元素之后，顺序表的长度:" << L.length <<"\n";
    cout <<"顺序表的元素为:" << endl;
    for(int i=0;i<L.length;i++)
    {
        cout <<L.val[i] << " ";
    }
    cout << endl;
    // 测试获取元素函数
    TestPrint("------------------取值函数测试---------------");
    int v;
    if (!GetVal(L,3,v))
    {
        cout <<"获取失败!";
    }
    cout <<"第" << 3 << "个位置的元素为:" << v <<endl;
    // 测试查找函数
    TestPrint("------------------查找函数测试---------------");
    v = -2;
    int index = LocateVal(L,v);
    if (index != -1)
        cout <<"元素" << v <<"的索引为:" << index <<endl;
    else
        cout <<"查找失败!";

    delete[] L.val;

    return 0;
}

/**
 * 查找指定元素
 * @param L  顺序表
 * @param v 指定元素
 * @return 成功返回元素索引，失败返回-1
 */
int  LocateVal(SqlList L,int v)
{
    int i;
    for(i=0;i<L.length;i++)
    {
        if (L.val[i] == v) return i;
    }
    return -1;
}
```

> 顺序表的元素为:
> 0 3 45 6 -23 8 -2 10 
> [------------------取值函数测试---------------]
> 第3个位置的元素为:45
> [------------------查找函数测试---------------]
> 元素-2的索引为:6

**算法复杂度:**

- 最好情况:

  如果需要查找的目标元素刚好在顺序表第一个位置，那么只需要比较一次即可查找成功，此时时间复杂度:
  $$
  O(1)
  $$

- 平均情况:

  由上，假设目标元素在第一个位置需要比较`1`次，第二个位置需要比比较`2`次...则最后一个位置处需要比较 `n`次。 

  得出:元素在第`i`个位置则需要比较`i`次，那么把所有情况下的比较次数乘以每次的查找概率`pi`并求和的结果即为平均时间复杂度。

  假设查找概率均等且均为`1/n`，则有：
  $$
  \sum_{n}^{i=1}p_{i}\times i = \frac{1}{n}\sum_{n}^{i=1}=\frac{1}{n}(1+2+3+...+n)=\frac{n+1}{2}
  $$
  所以，若假设**每个元素的查找概率相等**成立，则顺序表的平均时间复杂度:
  $$
  O(n)
  $$

- 最坏情况:

  如果目标元素刚好在顺序表最后一个位置，则需要比较`n`次查找成功，则其时间复杂度:
  $$
  O(n)
  $$

****

#### 插入(ListInsert)

在顺序表中第`i`个位置之前插入一个元素`v`。

在插入元素之前，我们需要顺序表从最后一个元素开始后移一位，直到将第`i`个元素也后移一位。

这样做的目的是给待插入元素留出一个空位。

**算法步骤:**

- 判断所给目标插入位置`i`的合法性，(在第一个元素之前或者最后一个元素之后插入)。
- 判断是否表满。
- 依次后移，给目标元素流出插入的空位(空出第`i`个位置)。
- 将目标元素插入到第`i`个位置。
- 表长递增，完成插入。

**图解：**

> 下图以在顺序表:`[8,7,-1,2,0,11,1]`中的第5个位置之前插入元素`5`的步骤为例。

1. 从最后一个元素开始，将元素`1`后移一位。

![c54a72753a1b57102b70c71d7f96784](https://images.waer.ltd/notes/202305042142229.jpg)

2. 继续，将元素`11`后移一位。

![665d00d02a389d933bb9da9aff7dd4a](https://images.waer.ltd/notes/202305042143051.jpg)

3. 继续，将元素`0`后移一位。

![bfbd0d0505c445a483e5ac440848fba](https://images.waer.ltd/notes/202305042144584.jpg)

4. 此时空出了第`5`个位置。

![bfbd0d0505c445a483e5ac440848fba](https://images.waer.ltd/notes/202305042147644.jpg)

5. 将目标元素`5`插入到该空位，完成插入。

![91adffca0a998b4a55bb2f78b8d29f4](https://images.waer.ltd/notes/202305042148704.jpg)

**代码实现:**

```cpp
bool ListInsert(SqlList &L,int i,int v)
{
    if (i<1 || i > L.length + 1) return false; //插入位置合法性判断
    if (L.length == MaxSize) return false; //表满，无法插入
    for (int j = L.length-1;j >=i-1;j--) // 移位
        L.val[j+1] = L.val[j];
    L.val[i-1] = v; // 插入
    L.length++;
    return true; //完成插入
}
```

> [------------------插入函数测试---------------]
> 成功向第5个位置插入了元素:5
> 插入元素之后，顺序表的长度:8
> 顺序表的元素为:
> 8 7 -1 2 5 0 11 1

**算法复杂度:**

- 最好情况:

  当在顺序表表尾插入一个元素时，复杂度为常数级别:
  $$
  O(1)
  $$
  
- 平均情况:

  元素可以在第1个位置之前，第2个位置之前...第n个位置之前，第n+1个位置之前插入，共`n+1`种情况，每种情况的移动次数`n-i+1`。同理，将每种情况的移动次数乘以插入概率(假设为pi)并求和即为平均时间复杂度。因此，若每个位置的插入概率均为`1/(n+1)`,则:
  $$
  \sum_{i=1}^{n+1}p_{i}\times (n-i+1) = \frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{1}{n+1}(n+(n-1)+...+1+0)=\frac{n}{2}
  $$
  所以，平均时间复杂度为:
  $$
  O(n)
  $$

- 最坏情况:
  $$
  O(n)
  $$



****

#### 删除(ListDelete)

与插入类似，这里所说的删除也是删除第`i`个元素，顺序表的删除操作，本质上就是将待删除的元素后面的元素依次往前移动，直到覆盖掉删除元素所留出的空位，完成删除。

**算法步骤:**

- 删除位置的合法性判断；
- 暂存待删除元素`v`;
- 将第`i+1`到第`n`个元素依次前移一个位置；
- 表长减1，完成删除；

**图解**

> 手稿以删除顺序表:`[8,7,-1,2,0,11,12,9]`中的第5个元素的步骤为例。

1. 确定待删除的目标元素`0`，将其后一个元素`11`前移一位，此时空出原`11`所在的位置；

![img_v2_39eb32ca-d625-40c1-af52-90cae0db8d4g](https://images.waer.ltd/notes/202305052109684.jpg)

2. 将空位之后的下一个元素`12`前移一位，空出自身的位置；

![img_v2_7c5260a6-eb88-497b-838f-328110ae1aag](https://images.waer.ltd/notes/202305052111598.jpg)

3. 同理，将元素`9`继续前移，此时整个顺序表长度减`1`,完成删除；

![img_v2_76bdd789-c44f-4c16-9913-56a32f7ee02g](https://images.waer.ltd/notes/202305052112157.jpg)

**代码实现:**

```cpp
/**
 * 删除第i个元素
 * @param L 顺序表
 * @param i 第i个元素
 * @param v 暂存待删除的元素
 * @return bool
 */
bool ListDelete(SqlList &L,int i,int &v)
{
    if (i < 1 || i >L.length) return false; //合法性判断
    v = L.val[i-1]; // 暂存待删除的元素，如果确定不需要返回删除元素的情况下，可以省略这一步
    for (int j = i;j <= L.length-1;j++)
        L.val[j-1] = L.val[j]; //第i个后面的元素依次向前移动
    L.length--;
    return true;
}
```

**算法复杂度:**

​	顺序表元素的删除一共有`n`种情况，每种情况移动的次数为`n-i`。将移动次数乘以删除概率`pi`,即为平均时间复杂度，假设删除每个元素的概率相等且为`1/n`，则平均时间复杂度:
$$
\sum_{i=1}^{n}p_{i}\times (n-i) = \frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{1}{n}((n-1)+...+1+0)=\frac{n-1}{2}
$$
即:
$$
O(n)
$$

****

#### 完整的测试代码

```cpp
// 测试初始化函数
void test_InitList() {
    SqlList L;
    bool res = InitList(L);
    if (res) {
        cout << "InitList测试通过" << endl;
    } else {
        cout << "InitList测试不通过" << endl;
    }
}
// 测试创建函数
void test_CreateList() {
    SqlList L;
    bool res = CreateList(L);
    if (res) {
        cout << "CreateList测试通过" << endl;
    } else {
        cout << "CreateList测试不通过" << endl;
    }
}
// 测试获取元素函数
void test_GetVal() {
    SqlList L;
    bool res = InitList(L);
    if (!res) {
        cout << "GetVal测试不通过，顺序表初始化失败" << endl;
        return;
    }
    res = CreateList(L);
    if (!res) {
        cout << "GetVal测试不通过，顺序表创建失败" << endl;
        return;
    }
    int i = 0;
    cout << "请输入要获取的第几个元素的位置（1-" << L.length << "）：";
    cin >> i;
    int v;
    res = GetVal(L, i, v);
    if (res) {
        cout << "GetVal测试通过，获取到第" << i << "个元素是" << v << endl;
    } else {
        cout << "GetVal测试不通过" << endl;
    }
}
// 测试查找元素函数
void test_LocateVal() {
    SqlList L;
    bool res = InitList(L);
    if (!res) {
        cout << "LocateVal测试不通过，顺序表初始化失败" << endl;
        return;
    }
    res = CreateList(L);
    if (!res) {
        cout << "LocateVal测试不通过，顺序表创建失败" << endl;
        return;
    }
    int v = 0;
    cout << "请输入要查找的元素值：";
    cin >> v;
    int index = LocateVal(L, v);
    if (index != -1) {
        cout << "LocateVal测试通过，元素" << v << "的位置是" << index + 1 << endl;
    } else {
        cout << "LocateVal测试不通过" << endl;
    }
}
// 测试插入元素函数
void test_ListInsert() {
    SqlList L;
    bool res = InitList(L);
    if (!res) {
        cout << "ListInsert测试不通过，顺序表初始化失败" << endl;
        return;
    }
    res = CreateList(L);
    if (!res) {
        cout << "ListInsert测试不通过，顺序表创建失败" << endl;
        return;
    }
    cout << "请输入要插入的位置和值（位置从1开始）：";
    int i, v;
    cin >> i >> v;
    res = ListInsert(L, i, v);
    if (res) {
        cout << "ListInsert测试通过，插入成功，插入后的列表为：";
        for (int j = 0; j < L.length; j++) {
            cout << L.val[j] << " ";
        }
        cout << endl;
    } else {
        cout << "ListInsert测试不通过" << endl;
    }
}
// 测试删除元素函数
void test_ListDelete() {
    SqlList L;
    bool res = InitList(L);
    if (!res) {
        cout << "ListDelete测试不通过，顺序表初始化失败" << endl;
        return;
    }
    res = CreateList(L);
    if (!res) {
        cout << "ListDelete测试不通过，顺序表创建失败" << endl;
        return;
    }
    cout << "请输入要删除的位置（位置从1开始）：";
    int i;
    cin >> i;
    int v;
    res = ListDelete(L, i, v);
    if (res) {
        cout << "ListDelete测试通过，删除成功，删除的元素值为" << v << "，删除后的列表为：";
        for (int j = 0; j < L.length; j++) {
            cout << L.val[j] << " ";
        }
        cout << endl;
    } else {
        cout << "ListDelete测试不通过" << endl;
    }
}
// 测试入口函数
int main() {
    test_InitList();
    test_CreateList();
    test_GetVal();
    test_LocateVal();
    test_ListInsert();
    test_ListDelete();
    return 0;
}
```

****

#### 小结

**顺序表优点:**

- 操作简单，存储密度高，可以随机存取，其中取出元素只需要`O(1)`的时间；

**顺序表缺点:**

- 需要预先计算好并分配所需空间，否则可能会造成空间浪费。

- 插入和删除操作需要移动其他元素，牵一发而动全身，效率不高。

****



## 纸解单链表

